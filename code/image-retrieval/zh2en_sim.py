from __future__ import print_function
import logging

logger = logging.getLogger(__file__)
logging.basicConfig(
    format="[%(asctime)s - %(filename)s:line %(lineno)s] %(message)s",
    datefmt='%d %b %H:%M:%S')
logger.setLevel(logging.INFO)

import os
import sys
import numpy as np
from keras.utils import generic_utils
from utils.simer import get_simer
from utils.eval_perf import cal_perf
from basic.constant import ROOT_PATH
from basic.common import makedirsforfile, checkToSkip

'''
    calculate the cosine distance between zh_text & en_text, according to the sent_feat.txt which is generated by w2vv
'''

def process(options, zh_testCollection, en_testCollection, w2vv_config):
    rootpath = options.rootpath
    overwrite = options.overwrite
    zh_trainCollection = options.zh_trainCollection
    en_trainCollection = options.en_trainCollection
    
    zh_feat_dir = os.path.join(rootpath, zh_testCollection, 'SimilarityIndex', zh_trainCollection, w2vv_config)
    en_feat_dir = os.path.join(rootpath, en_testCollection, 'SimilarityIndex', en_trainCollection, w2vv_config)
    output_dir = os.path.join(rootpath, zh_testCollection, 'SimilarityIndex', zh_trainCollection, "zh2en_"+w2vv_config)
    result_pred_sents = os.path.join(output_dir, 'sent.id.score.txt')

    recall_file = os.path.join(output_dir, 'recall.txt')

    if checkToSkip(result_pred_sents, overwrite):
        sys.exit(0)
    makedirsforfile(result_pred_sents)

    zh_sent_feat = os.path.join(zh_feat_dir, "sent_feat.txt")
    en_sent_feat = os.path.join(en_feat_dir, "sent_feat.txt")

    logger.info("zh_sent_feat: %s", zh_sent_feat)
    logger.info("en_sent_feat: %s", en_sent_feat)
    logger.info(result_pred_sents)

    zh_fin = open(zh_sent_feat, 'r')
    en_fin = open(en_sent_feat, 'r')
    fout = open(result_pred_sents, 'w')

    zh_text_feat_batch = []
    zh_text_id_batch = []
    for line in zh_fin.readlines():
        textid, feat = line.strip().split(' ', 1)
        feat = map(float, feat.split(' '))
        zh_text_feat_batch.append(feat)
        zh_text_id_batch.append(textid)

    en_text_feat_batch = []
    en_text_id_batch =[]
    for line in en_fin.readlines():
        textid, feat = line.strip().split(' ', 1)
        feat = map(float, feat.split(' '))
        en_text_feat_batch.append(feat)
        en_text_id_batch.append(textid)

    zh_fin.close()
    en_fin.close()
    logger.info('feat batch size: %d, %d', len(zh_text_feat_batch), len(en_text_feat_batch))
    assert len(zh_text_feat_batch) == len(en_text_feat_batch)

    test_progbar = generic_utils.Progbar(len(zh_text_feat_batch))
    counter = 0

    simer = get_simer("cosine_batch")()

    logger.info("matching zh_text and en_text")
    scorelist_batch = simer.calculate(zh_text_feat_batch, en_text_feat_batch)
    assert len(scorelist_batch) == len(zh_text_feat_batch)
    for zh_text_id, scorelist in zip(zh_text_id_batch, scorelist_batch):
        top_hits = np.argsort(scorelist)[::-1]

        top_sents = []
        for idx in top_hits.tolist():
            top_sents.append(en_text_id_batch[idx])
            top_sents.append(scorelist[idx])

        fout.write(zh_text_id + ' ' + ' '.join(map(str, top_sents)) + '\n')
        counter += 1
        test_progbar.update(counter)
    assert counter == len(zh_text_feat_batch)

    fout.close()

    recall_name, recall_score, med_r, mean_r, mean_invert_r = cal_perf(result_pred_sents)
    #fout_recall = open(os.path.join(output_dir, 'recall.txt'), 'w')
    #fout_recall.write(recall_name + '\n' + recall_score + '\n')
    #fout_recall.write('med_r:' + '\n' + str(med_r) + '\n')
    #fout_recall.write('mean_r:' + '\n' + str(mean_r) + '\n')
    #fout_recall.write('mean_invert_r:' + '\n' + str(mean_invert_r) + '\n')
    fout_recall = open(os.path.join(output_dir, 'mir.txt'), 'w')
    fout_recall.write('mean_invert_r: {}\n'.format(round(mean_invert_r, 3)))
    fout_recall.close()

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    from optparse import OptionParser
    parser = OptionParser(usage="""usage: %prog [options] zh_testCollection en_testCollection w2vv_config""")

    parser.add_option("--overwrite", default=0, type="int", help="overwrite existing file (default: 0)")
    parser.add_option("--rootpath", default=ROOT_PATH, type="string", help="rootpath (default: %s)" % ROOT_PATH)
    parser.add_option("--zh_trainCollection", default="cococntrain", type="string", help="Chinese training set (default: cococntrain)")
    parser.add_option("--en_trainCollection", default="mscoc2014dev-train", type="string", help="English training set (default: mscoco2014dev-train)")


    (options, args) = parser.parse_args(argv)
    if len(args) < 3:
        parser.print_help()
        return 1
    process(options, args[0], args[1], args[2])

if __name__ == '__main__':
    sys.exit(main())


